package identity_manager

import (
	"strings"
	"testing"

	"github.com/google/uuid"
)

func TestNewUUIDV4_GeneratesValidUUID(t *testing.T) {
	// Act
	generatedUUID := NewUUIDV4()

	// Assert
	if generatedUUID == "" {
		t.Error("Expected non-empty UUID, got empty string")
	}

	// Verifica se é um UUID válido
	_, err := uuid.Parse(generatedUUID)
	if err != nil {
		t.Errorf("Generated UUID is not valid: %v", err)
	}

	// Verifica o formato do UUID (deve ter 36 caracteres com hífens)
	if len(generatedUUID) != 36 {
		t.Errorf("Expected UUID length 36, got %d", len(generatedUUID))
	}

	// Verifica se contém hífens nas posições corretas
	expectedHyphenPositions := []int{8, 13, 18, 23}
	for _, pos := range expectedHyphenPositions {
		if generatedUUID[pos] != '-' {
			t.Errorf("Expected hyphen at position %d, got %c", pos, generatedUUID[pos])
		}
	}
}

func TestNewUUIDV4_GeneratesUniqueUUIDs(t *testing.T) {
	// Arrange
	uuids := make(map[string]bool)
	iterations := 1000

	// Act & Assert
	for i := 0; i < iterations; i++ {
		generatedUUID := NewUUIDV4()

		if uuids[generatedUUID] {
			t.Errorf("Duplicate UUID generated: %s", generatedUUID)
		}

		uuids[generatedUUID] = true
	}

	if len(uuids) != iterations {
		t.Errorf("Expected %d unique UUIDs, got %d", iterations, len(uuids))
	}
}

func TestIsValidUUID_ValidUUIDs(t *testing.T) {
	// Arrange
	validUUIDs := []string{
		"550e8400-e29b-41d4-a716-446655440000",
		"6ba7b810-9dad-11d1-80b4-00c04fd430c8",
		"6ba7b811-9dad-11d1-80b4-00c04fd430c8",
		"00000000-0000-0000-0000-000000000000",
		NewUUIDV4(), // UUID gerado dinamicamente
	}

	// Act & Assert
	for _, validUUID := range validUUIDs {
		if !IsValidUUID(validUUID) {
			t.Errorf("Expected UUID %s to be valid, but IsValidUUID returned false", validUUID)
		}
	}
}

func TestIsValidUUID_InvalidUUIDs(t *testing.T) {
	// Arrange
	invalidUUIDs := []string{
		"",                        // Empty string
		"invalid-uuid",            // Invalid format
		"550e8400-e29b-41d4-a716", // Too short
		"550e8400-e29b-41d4-a716-446655440000-extra", // Too long
		"550e8400-e29b-41d4-a716-44665544000g",       // Invalid character
		"550e8400-e29b-41d4-a716-44665544000",        // Wrong length in last segment
		"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",       // Invalid characters
	}

	// Act & Assert
	for _, invalidUUID := range invalidUUIDs {
		if IsValidUUID(invalidUUID) {
			t.Errorf("Expected UUID %s to be invalid, but IsValidUUID returned true", invalidUUID)
		}
	}
}

func TestIsNotValidUUID_ValidUUIDs(t *testing.T) {
	// Arrange
	validUUIDs := []string{
		"550e8400-e29b-41d4-a716-446655440000",
		"6ba7b810-9dad-11d1-80b4-00c04fd430c8",
		NewUUIDV4(),
	}

	// Act & Assert
	for _, validUUID := range validUUIDs {
		if IsNotValidUUID(validUUID) {
			t.Errorf("Expected UUID %s to be valid, but IsNotValidUUID returned true", validUUID)
		}
	}
}

func TestIsNotValidUUID_InvalidUUIDs(t *testing.T) {
	// Arrange
	invalidUUIDs := []string{
		"",
		"invalid-uuid",
		"550e8400-e29b-41d4-a716",
		"550e8400-e29b-41d4-a716-446655440000-extra",
	}

	// Act & Assert
	for _, invalidUUID := range invalidUUIDs {
		if !IsNotValidUUID(invalidUUID) {
			t.Errorf("Expected UUID %s to be invalid, but IsNotValidUUID returned false", invalidUUID)
		}
	}
}

func TestIsValidUUID_AndIsNotValidUUID_AreOpposite(t *testing.T) {
	// Arrange
	testUUIDs := []string{
		"550e8400-e29b-41d4-a716-446655440000", // Valid
		"invalid-uuid",                         // Invalid
		NewUUIDV4(),                            // Valid (generated)
		"",                                     // Invalid (empty)
	}

	// Act & Assert
	for _, testUUID := range testUUIDs {
		isValid := IsValidUUID(testUUID)
		isNotValid := IsNotValidUUID(testUUID)

		if isValid == isNotValid {
			t.Errorf("IsValidUUID and IsNotValidUUID should return opposite values for UUID %s", testUUID)
		}
	}
}

func TestNewUUIDV4_Format(t *testing.T) {
	// Act
	generatedUUID := NewUUIDV4()

	// Assert
	// Verifica se o UUID está em lowercase (formato padrão do google/uuid)
	if strings.ToLower(generatedUUID) != generatedUUID {
		t.Errorf("Expected UUID to be in lowercase, got %s", generatedUUID)
	}

	// Verifica se não contém caracteres inválidos
	validChars := "0123456789abcdef-"
	for _, char := range generatedUUID {
		if !strings.ContainsRune(validChars, char) {
			t.Errorf("UUID contains invalid character: %c", char)
		}
	}
}

func TestUUIDFunctions_Integration(t *testing.T) {
	// Arrange & Act
	generatedUUID := NewUUIDV4()

	// Assert
	if !IsValidUUID(generatedUUID) {
		t.Errorf("UUID generated by NewUUIDV4() should be valid: %s", generatedUUID)
	}

	if IsNotValidUUID(generatedUUID) {
		t.Errorf("UUID generated by NewUUIDV4() should not be invalid: %s", generatedUUID)
	}
}
